;
; Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
;
; SPDX-License-Identifier: BSD-3-Clause
;
.pio_version 0 // only requires PIO version 0

.program uart_rx_mini

.wrap_target
    wait 1 pin 0        ; ждем высокий уровень (idle)
    set pins, 1         ; подаем стартовый импульс на выход
    wait 0 pin 0        ; ждем переход в 0 (старт-бит)
    set pins, 0         ; фиксируем 0 на выходе
.wrap

% c-sdk {
#include "hardware/clocks.h"
#include "hardware/gpio.h"

static inline void uart_rx_mini_program_init(PIO pio, uint sm, uint offset, uint pinin, uint pinout , uint baud) {
    
    pio_sm_set_consecutive_pindirs(pio, sm, pinin, 1, false);
    pio_gpio_init(pio, pinin);
gpio_pull_up(pinin);
    pio_sm_set_consecutive_pindirs(pio, sm, pinout, 1, true);
pio_gpio_init(pio, pinout);
    //gpio_pull_up(pinout);
pio_sm_config c = uart_rx_mini_program_get_default_config(offset);
    sm_config_set_in_pins(&c, pinin); // for WAIT, IN
    //sm_config_set_out_pins(&c, pinout, 1);
    sm_config_set_sideset_pins(&c, pinout);
    sm_config_set_set_pins(&c, pinout, 1);
    
    // Shift to right, autopush enabled
    sm_config_set_in_shift(&c, true, false, 1);
    sm_config_set_out_shift(&c, true, false, 1);
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_NONE);
    
    // SM transmits 1 bit per 8 execution cycles.
    float div = (float)clock_get_hz(clk_sys) / (baud);
    sm_config_set_clkdiv(&c, div);
    
    pio_sm_init(pio, sm, offset, &c);
    // pio_sm_set_enabled(pio, sm, true);
}
%}

.program uart_rx
; Полный приёмник 8n1 для UART RX c проверкой стоп-бита/ошибок

start:
    wait 0 pin 0        ; Ждем старт-бит (падение линии)
    set x, 7    [10]    ; Счётчик битов = 7, задержка до середины 1-го бита
bitloop:                ; Цикл выборки 8 бит (каждый шаг 8 циклов)
    in pins, 1          ; Сдвиг 1 бита в ISR
    jmp x-- bitloop [6] ; Повторять, пока X не станет -1
    jmp pin good_stop   ; Проверяем стоп-бит (должен быть 1)

    irq 4 rel           ; Ошибка кадра/обрыв — ставим флаг
    wait 1 pin 0        ; Ждем возврата линии в idle
    jmp start           ; Плохой кадр не пушим

good_stop:              ; Стоп-бит валиден
    push                ; Кладем байт в FIFO


% c-sdk {
static inline void uart_rx_program_init(PIO pio, uint sm, uint offset, uint pinin, uint pinout , uint baud) {
    pio_sm_set_consecutive_pindirs(pio, sm, pinin, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm, pinout, 1, true);
    pio_gpio_init(pio, pinin);
    pio_gpio_init(pio, pinout);
    gpio_pull_up(pinin);

    pio_sm_config c = uart_rx_program_get_default_config(offset);
    sm_config_set_in_pins(&c, pinin); // for WAIT, IN
    sm_config_set_jmp_pin(&c, pinin); // for JMP
    sm_config_set_out_pins(&c, pinout, 1);
    // Shift to right, autopush disabled
    sm_config_set_in_shift(&c, true, true, 32);
    // Deeper FIFO as we're not doing any TX
    // sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
    // SM transmits 1 bit per 8 execution cycles.
    float div = (float)clock_get_hz(clk_sys) / (8 * baud);
    sm_config_set_clkdiv(&c, div);
    
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

static inline char uart_rx_program_getc(PIO pio, uint sm) {
    // 8-bit read from the uppermost byte of the FIFO, as data is left-justified
    io_rw_8 *rxfifo_shift = (io_rw_8*)&pio->rxf[sm] + 3;
    while (pio_sm_is_rx_fifo_empty(pio, sm))
        tight_loop_contents();
    return (uint8_t)*rxfifo_shift;
}

%}
